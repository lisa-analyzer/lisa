package it.unive.lisa.analysis.dataflow;

import it.unive.lisa.analysis.SemanticEvaluator;
import it.unive.lisa.analysis.SemanticException;
import it.unive.lisa.analysis.SemanticOracle;
import it.unive.lisa.analysis.value.ValueDomain;
import it.unive.lisa.program.cfg.ProgramPoint;
import it.unive.lisa.symbolic.SymbolicExpression;
import it.unive.lisa.symbolic.value.Identifier;
import it.unive.lisa.symbolic.value.PushInv;
import it.unive.lisa.symbolic.value.ValueExpression;
import it.unive.lisa.type.Type;
import it.unive.lisa.util.functional.Supplier;
import java.util.Set;
import java.util.function.BooleanSupplier;

/**
 * A dataflow domain that collects instances of {@link DataflowElement} either
 * in a {@link PossibleSet} or a {@link DefiniteSet}.
 * 
 * @author <a href="mailto:luca.negrini@unive.it">Luca Negrini</a>
 * 
 * @param <L> the type of {@link DataflowDomainLattice} that this domain
 *                operates on
 * @param <E> the concrete type of {@link DataflowElement} contained in this
 *                domain
 */
public abstract class DataflowDomain<L extends DataflowDomainLattice<L, E>,
		E extends DataflowElement<E>>
		implements
		ValueDomain<L>,
		SemanticEvaluator {

	@Override
	public L assign(
			L state,
			Identifier id,
			ValueExpression expression,
			ProgramPoint pp,
			SemanticOracle oracle)
			throws SemanticException {
		return update(
				state,
				() -> !canProcess(expression, pp, oracle),
				() -> gen(state, id, expression, pp),
				() -> kill(state, id, expression, pp));
	}

	@Override
	public L smallStepSemantics(
			L state,
			ValueExpression expression,
			ProgramPoint pp,
			SemanticOracle oracle)
			throws SemanticException {
		return update(
				state,
				() -> !canProcess(expression, pp, oracle),
				() -> gen(state, expression, pp),
				() -> kill(state, expression, pp));
	}

	private L update(
			L state,
			BooleanSupplier guard,
			Supplier<Set<E>, SemanticException> gen,
			Supplier<Set<E>, SemanticException> kill)
			throws SemanticException {
		if (state.isBottom())
			return state;

		if (guard.getAsBoolean())
			return state;

		return state.update(kill.get(), gen.get());
	}

	@Override
	public L assume(
			L state,
			ValueExpression expression,
			ProgramPoint src,
			ProgramPoint dest,
			SemanticOracle oracle)
			throws SemanticException {
		return state;
	}

	@Override
	public boolean canProcess(
			SymbolicExpression expression,
			ProgramPoint pp,
			SemanticOracle oracle) {
		if (expression instanceof PushInv)
			// the type approximation of a pushinv is bottom, so the below check
			// will always fail regardless of the kind of value we are tracking
			return expression.getStaticType().isValueType();

		Set<Type> rts = null;
		try {
			rts = oracle.getRuntimeTypesOf(expression, pp);
		} catch (SemanticException e) {
			return false;
		}

		if (rts == null || rts.isEmpty())
			// if we have no runtime types, either the type domain has no type
			// information for the given expression (thus it can be anything,
			// also something that we can track) or the computation returned
			// bottom (and the whole state is likely going to go to bottom
			// anyway).
			return true;

		return rts.stream().anyMatch(Type::isValueType);
	}

	/**
	 * The dataflow <i>gen</i> operation, yielding the dataflow elements that
	 * are generated by the assignment of the given {@code expression} to the
	 * given {@code id}.
	 * 
	 * @param state      the current dataflow elements
	 * @param id         the {@link Identifier} being assigned
	 * @param expression the expressions that is being assigned to {@code id}
	 * @param pp         the program point where this operation happens
	 * 
	 * @return the collection of dataflow elements that are generated by the
	 *             assignment
	 * 
	 * @throws SemanticException if an error occurs during the computation
	 */
	public abstract Set<E> gen(
			L state,
			Identifier id,
			ValueExpression expression,
			ProgramPoint pp)
			throws SemanticException;

	/**
	 * The dataflow <i>gen</i> operation, yielding the dataflow elements that
	 * are generated by evaluating the given non-assigning {@code expression}.
	 * 
	 * @param state      the current dataflow elements
	 * @param expression the expressions that is being evaluated
	 * @param pp         the program point where this operation happens
	 * 
	 * @return the collection of dataflow elements that are generated by the
	 *             expression
	 * 
	 * @throws SemanticException if an error occurs during the computation
	 */
	public abstract Set<E> gen(
			L state,
			ValueExpression expression,
			ProgramPoint pp)
			throws SemanticException;

	/**
	 * The dataflow <i>kill</i> operation, yielding the dataflow elements that
	 * are killed by the assignment of the given {@code expression} to the given
	 * {@code id}.
	 * 
	 * @param state      the current dataflow elements
	 * @param id         the {@link Identifier} being assigned
	 * @param expression the expressions that is being assigned to {@code id}
	 * @param pp         the program point where this operation happens
	 * 
	 * @return the collection of dataflow elements that are killed by the
	 *             assignment
	 * 
	 * @throws SemanticException if an error occurs during the computation
	 */
	public abstract Set<E> kill(
			L state,
			Identifier id,
			ValueExpression expression,
			ProgramPoint pp)
			throws SemanticException;

	/**
	 * The dataflow <i>kill</i> operation, yielding the dataflow elements that
	 * are killed by evaluating the given non-assigning {@code expression}.
	 * 
	 * @param state      the current dataflow elements
	 * @param expression the expressions that is being evaluated
	 * @param pp         the program point where this operation happens
	 * 
	 * @return the collection of dataflow elements that are killed by the
	 *             expression
	 * 
	 * @throws SemanticException if an error occurs during the computation
	 */
	public abstract Set<E> kill(
			L state,
			ValueExpression expression,
			ProgramPoint pp)
			throws SemanticException;

}
